<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/AiDemoTransport/Services/Messaging/RabbitMqPublisher.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AiDemoTransport/Services/Messaging/RabbitMqPublisher.cs" />
              <option name="originalContent" value="using RabbitMQ.Client;&#10;using Newtonsoft.Json;&#10;using System.Text;&#10;using AiDemoTransport.Services.Messaging;&#10;&#10;namespace AiDemoTransport.Services.Messaging;&#10;&#10;public class RabbitMqPublisher : IMessagePublisher, IDisposable&#10;{&#10;    private readonly IConnection _connection;&#10;    private readonly IModel _channel;&#10;    private readonly ILogger&lt;RabbitMqPublisher&gt; _logger;&#10;&#10;    public RabbitMqPublisher(IConfiguration configuration, ILogger&lt;RabbitMqPublisher&gt; logger)&#10;    {&#10;        _logger = logger;&#10;        &#10;        var factory = new ConnectionFactory&#10;        {&#10;            HostName = configuration.GetValue&lt;string&gt;(&quot;RabbitMQ:HostName&quot;) ?? &quot;localhost&quot;,&#10;            Port = configuration.GetValue&lt;int&gt;(&quot;RabbitMQ:Port&quot;, 5672),&#10;            UserName = configuration.GetValue&lt;string&gt;(&quot;RabbitMQ:UserName&quot;) ?? &quot;guest&quot;,&#10;            Password = configuration.GetValue&lt;string&gt;(&quot;RabbitMQ:Password&quot;) ?? &quot;guest&quot;,&#10;            VirtualHost = configuration.GetValue&lt;string&gt;(&quot;RabbitMQ:VirtualHost&quot;) ?? &quot;/&quot;&#10;        };&#10;&#10;        try&#10;        {&#10;            _connection = factory.CreateConnection();&#10;            _channel = _connection.CreateModel();&#10;            &#10;            // Declare the exchange for transport events&#10;            _channel.ExchangeDeclare(&#10;                exchange: &quot;transport.events&quot;,&#10;                type: ExchangeType.Topic,&#10;                durable: true,&#10;                autoDelete: false&#10;            );&#10;            &#10;            _logger.LogInformation(&quot;RabbitMQ connection established successfully&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            _logger.LogError(ex, &quot;Failed to establish RabbitMQ connection&quot;);&#10;            throw;&#10;        }&#10;    }&#10;&#10;    public async Task PublishAsync&lt;T&gt;(T message, string exchange, string routingKey) where T : class&#10;    {&#10;        try&#10;        {&#10;            var json = JsonConvert.SerializeObject(message, Formatting.Indented);&#10;            var body = Encoding.UTF8.GetBytes(json);&#10;&#10;            var properties = _channel.CreateBasicProperties();&#10;            properties.Persistent = true;&#10;            properties.MessageId = Guid.NewGuid().ToString();&#10;            properties.Timestamp = new AmqpTimestamp(DateTimeOffset.UtcNow.ToUnixTimeSeconds());&#10;            properties.ContentType = &quot;application/json&quot;;&#10;&#10;            _channel.BasicPublish(&#10;                exchange: exchange,&#10;                routingKey: routingKey,&#10;                basicProperties: properties,&#10;                body: body&#10;            );&#10;&#10;            _logger.LogInformation(&quot;Published message to exchange '{Exchange}' with routing key '{RoutingKey}': {MessageType}&quot;,&#10;                exchange, routingKey, typeof(T).Name);&#10;            &#10;            await Task.CompletedTask;&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            _logger.LogError(ex, &quot;Failed to publish message to exchange '{Exchange}' with routing key '{RoutingKey}'&quot;,&#10;                exchange, routingKey);&#10;            throw;&#10;        }&#10;    }&#10;&#10;    public async Task PublishAsync&lt;T&gt;(T message, string queueName) where T : class&#10;    {&#10;        try&#10;        {&#10;            // Declare queue if it doesn't exist&#10;            _channel.QueueDeclare(&#10;                queue: queueName,&#10;                durable: true,&#10;                exclusive: false,&#10;                autoDelete: false&#10;            );&#10;&#10;            var json = JsonConvert.SerializeObject(message, Formatting.Indented);&#10;            var body = Encoding.UTF8.GetBytes(json);&#10;&#10;            var properties = _channel.CreateBasicProperties();&#10;            properties.Persistent = true;&#10;            properties.MessageId = Guid.NewGuid().ToString();&#10;            properties.Timestamp = new AmqpTimestamp(DateTimeOffset.UtcNow.ToUnixTimeSeconds());&#10;            properties.ContentType = &quot;application/json&quot;;&#10;&#10;            _channel.BasicPublish(&#10;                exchange: &quot;&quot;,&#10;                routingKey: queueName,&#10;                basicProperties: properties,&#10;                body: body&#10;            );&#10;&#10;            _logger.LogInformation(&quot;Published message to queue '{QueueName}': {MessageType}&quot;,&#10;                queueName, typeof(T).Name);&#10;                &#10;            await Task.CompletedTask;&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            _logger.LogError(ex, &quot;Failed to publish message to queue '{QueueName}'&quot;, queueName);&#10;            throw;&#10;        }&#10;    }&#10;&#10;    public void Dispose()&#10;    {&#10;        try&#10;        {&#10;            _channel?.Close();&#10;            _channel?.Dispose();&#10;            _connection?.Close();&#10;            _connection?.Dispose();&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            _logger.LogError(ex, &quot;Error disposing RabbitMQ resources&quot;);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using RabbitMQ.Client;&#10;using Newtonsoft.Json;&#10;using System.Text;&#10;using AiDemoTransport.Services.Messaging;&#10;&#10;namespace AiDemoTransport.Services.Messaging;&#10;&#10;public class RabbitMqPublisher : IMessagePublisher, IDisposable&#10;{&#10;    private readonly IConnection _connection;&#10;    private readonly IModel _channel;&#10;    private readonly ILogger&lt;RabbitMqPublisher&gt; _logger;&#10;&#10;    public RabbitMqPublisher(IConfiguration configuration, ILogger&lt;RabbitMqPublisher&gt; logger)&#10;    {&#10;        _logger = logger;&#10;        &#10;        var factory = new ConnectionFactory&#10;        {&#10;            HostName = configuration.GetValue&lt;string&gt;(&quot;RabbitMQ:HostName&quot;) ?? &quot;localhost&quot;,&#10;            Port = configuration.GetValue&lt;int&gt;(&quot;RabbitMQ:Port&quot;, 5672),&#10;            UserName = configuration.GetValue&lt;string&gt;(&quot;RabbitMQ:UserName&quot;) ?? &quot;guest&quot;,&#10;            Password = configuration.GetValue&lt;string&gt;(&quot;RabbitMQ:Password&quot;) ?? &quot;guest&quot;,&#10;            VirtualHost = configuration.GetValue&lt;string&gt;(&quot;RabbitMQ:VirtualHost&quot;) ?? &quot;/&quot;&#10;        };&#10;&#10;        try&#10;        {&#10;            _connection = factory.CreateConnection();&#10;            _channel = _connection.CreateModel();&#10;            &#10;            // Declare the exchange for transport events&#10;            _channel.ExchangeDeclare(&#10;                exchange: &quot;transport.events&quot;,&#10;                type: ExchangeType.Direct, // Changed from Topic to Direct&#10;                durable: true,&#10;                autoDelete: false&#10;            );&#10;            &#10;            _logger.LogInformation(&quot;RabbitMQ connection established successfully&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            _logger.LogError(ex, &quot;Failed to establish RabbitMQ connection&quot;);&#10;            throw;&#10;        }&#10;    }&#10;&#10;    public async Task PublishAsync&lt;T&gt;(T message, string exchange, string routingKey) where T : class&#10;    {&#10;        try&#10;        {&#10;            var json = JsonConvert.SerializeObject(message, Formatting.Indented);&#10;            var body = Encoding.UTF8.GetBytes(json);&#10;&#10;            var properties = _channel.CreateBasicProperties();&#10;            properties.Persistent = true;&#10;            properties.MessageId = Guid.NewGuid().ToString();&#10;            properties.Timestamp = new AmqpTimestamp(DateTimeOffset.UtcNow.ToUnixTimeSeconds());&#10;            properties.ContentType = &quot;application/json&quot;;&#10;&#10;            _channel.BasicPublish(&#10;                exchange: exchange,&#10;                routingKey: routingKey,&#10;                basicProperties: properties,&#10;                body: body&#10;            );&#10;&#10;            _logger.LogInformation(&quot;Published message to exchange '{Exchange}' with routing key '{RoutingKey}': {MessageType}&quot;,&#10;                exchange, routingKey, typeof(T).Name);&#10;            &#10;            await Task.CompletedTask;&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            _logger.LogError(ex, &quot;Failed to publish message to exchange '{Exchange}' with routing key '{RoutingKey}'&quot;,&#10;                exchange, routingKey);&#10;            throw;&#10;        }&#10;    }&#10;&#10;    public async Task PublishAsync&lt;T&gt;(T message, string queueName) where T : class&#10;    {&#10;        try&#10;        {&#10;            // Declare queue if it doesn't exist&#10;            _channel.QueueDeclare(&#10;                queue: queueName,&#10;                durable: true,&#10;                exclusive: false,&#10;                autoDelete: false&#10;            );&#10;&#10;            var json = JsonConvert.SerializeObject(message, Formatting.Indented);&#10;            var body = Encoding.UTF8.GetBytes(json);&#10;&#10;            var properties = _channel.CreateBasicProperties();&#10;            properties.Persistent = true;&#10;            properties.MessageId = Guid.NewGuid().ToString();&#10;            properties.Timestamp = new AmqpTimestamp(DateTimeOffset.UtcNow.ToUnixTimeSeconds());&#10;            properties.ContentType = &quot;application/json&quot;;&#10;&#10;            _channel.BasicPublish(&#10;                exchange: &quot;&quot;,&#10;                routingKey: queueName,&#10;                basicProperties: properties,&#10;                body: body&#10;            );&#10;&#10;            _logger.LogInformation(&quot;Published message to queue '{QueueName}': {MessageType}&quot;,&#10;                queueName, typeof(T).Name);&#10;                &#10;            await Task.CompletedTask;&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            _logger.LogError(ex, &quot;Failed to publish message to queue '{QueueName}'&quot;, queueName);&#10;            throw;&#10;        }&#10;    }&#10;&#10;    public void Dispose()&#10;    {&#10;        try&#10;        {&#10;            _channel?.Close();&#10;            _channel?.Dispose();&#10;            _connection?.Close();&#10;            _connection?.Dispose();&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            _logger.LogError(ex, &quot;Error disposing RabbitMQ resources&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>